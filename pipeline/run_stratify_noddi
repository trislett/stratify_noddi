#!/usr/bin/env python

import os
import json
import amico
import glob
import argparse as ap
import numpy as np
import nibabel as nib
import dipy.reconst.dti as dti
from dipy.reconst.dti import fractional_anisotropy, mean_diffusivity, radial_diffusivity, axial_diffusivity,mode
import dipy.denoise.noise_estimate as ne
import dipy.io as io
import dipy.core.gradients as cg

from stratify_noddi.functions import antsLinearRegCmd, antsNonLinearRegCmd, antsApplyTransformCmd, runCmd_log, antsBetCmd, check_dwi_files, generate_qc_tsv

DESCRIPTION = ""

def getArgumentParser(ap = ap.ArgumentParser(description = DESCRIPTION)):
	ap.add_argument("-s", "--subjid",
		nargs = 1,
		help = "Subject ID",
		metavar = ('str'),
		required = True)
	ap.add_argument("-dwi", "--dwipath",
		nargs = "+",
		help = "-dwi {bval} {bvec} {4D_dwiimage} [optional {json}]. E.g., -dwi path/to/sub-TEST.*",
		type = str,
		metavar = ('str'),
		required = True)
	edc_method = ap.add_mutually_exclusive_group(required = True)
	edc_method.add_argument("-pab0", "--pab0path",
		nargs = "+",
		help = "-padwi {4D_b0image} [{bval} {bvec} optional {json}]. E.g., -dwi path/to/sub-TEST.*",
		type = str,
		metavar = ('str'))
	edc_method.add_argument("-t1", "--t1path",
		nargs = 1,
		help = "-t1 {T1w_image}",
		type = str,
		metavar = ('str'))
	ap.add_argument("-trot", "--totalreadouttime",
		nargs = 1,
		help = "-trot {total readout time} (default: %(default)s)",
		type = str,
		metavar = ('str'),
		default = ['0.0876336'])
	ap.add_argument("--defaultnumopposingb0",
		nargs = 1,
		help = "--defaultnumopposingb0. Sets the number of pa b0s to extract from the start if pa vector/bval files are missing (default: %(default)s)",
		type = int,
		metavar = ('int'),
		default = [3])
	ap.add_argument("-rr", "--runrestore",
		help = "Use RESTORE for robust tensor fitting",
		action = "store_true")
	ap.add_argument("-nt", "--numthreads", 
		nargs=1,
		default=[2],
		type = int,
		help="Multithreading (default: %(default)s). Only partially implemented")
	return ap

def run(opts):

	# Naming convention V0.1
	# 1. RAW DATA
	# {subject}_dwi-AP.nii.gz 					the raw dti data
	# {subject}_dwi-AP.bvec 					gradient directions
	# {subject}_dwi-AP.bval 					b-values
	# 2. denoised
	# {subject}_dwi-AP_dn.nii.gz
	# {subject}_noise.nii.gz
	# 3. degibbs
	# {subject}_dwi-AP_dn_degibbsed
	# 4. eddy current correction
	# {subject}_dwi-AP_dn_degibbsed_ecc
	# {subject}_dwi-AP_dn_degibbsed_ecc.bvec
	# {subject}_dwi-AP_dn_degibbsed_ecc_mask
	# {subject}_dwi-AP_dn_degibbsed_ecc_brain
	# 5. distortion correction
	# {subject}_dwi-AP__dn_degibbsed_ecc_b0_mean.nii.gz				mean of b0 images
	# 6. dti linear fit (restore?)
	# {subject}_dwi-AP_dn_ecc_dc_brain_* 					DTI Metrics / NODDI Metrics

	subject = opts.subjid[0]
	BVAL_path = check_dwi_files(opts.dwipath, ".bval")
	BVEC_path = check_dwi_files(opts.dwipath, ".bvec")
	DWI_path = check_dwi_files(opts.dwipath, ".nii.gz")
	JSON_path = check_dwi_files(dwi_opts = opts.dwipath, extension = '.json')
	numthreads = opts.numthreads[0]
	TotalReadoutTime = str(opts.totalreadouttime[0])
	N_PA_B0 = int(opts.defaultnumopposingb0[0])

	if JSON_path is not None:
		with open(JSON_path) as dwi_json_file:
			dwi_json = json.load(dwi_json_file)
		TotalReadoutTime = str(dwi_json["TotalReadoutTime"])
		print("Total Readout Time from %s is: %s" % (JSON_path, TotalReadoutTime))

	if opts.t1path:
		T1w_path = opts.t1path[0]
		T1w_path = os.path.abspath(T1w_path)
	if opts.pab0path:
		pa_BVAL_path = check_dwi_files(opts.pab0path, ".bval")
		pa_BVEC_path = check_dwi_files(opts.pab0path, ".bvec")
		pa_DWI_path = check_dwi_files(opts.pab0path, ".nii.gz")

	DWI_path = os.path.abspath(DWI_path)
	BVEC_path = os.path.abspath(BVEC_path)
	BVAL_path = os.path.abspath(BVAL_path)

	runCmd_log("mkdir -p %s" % subject)
	os.chdir(subject)
	pdir_basename = os.getcwd() + "/"

	# copy and rename dwi
	runCmd_log("mkdir -p processed")
	
	# declare names
	DWI = pdir_basename + "processed/%s_dwi-AP.nii.gz" % subject
	BVAL = pdir_basename + "processed/%s_dwi-AP.bval" % subject
	BVEC = pdir_basename + "processed/%s_dwi-AP.bvec" % subject

	runCmd_log("cp %s %s" % (DWI_path, DWI))
	runCmd_log("cp %s %s" % (BVAL_path, BVAL))
	runCmd_log("cp %s %s" % (BVEC_path, BVEC))

	if opts.t1path:
		T1W = pdir_basename + "processed/%s_T1w.nii.gz" % subject
		runCmd_log("cp %s %s" % (T1w_path, T1W))
	if opts.pab0path:
		if pa_BVAL_path is not None:
			paBVAL = pdir_basename + "processed/%s_dwi-PA.nii.gz" % subject
			runCmd_log("cp %s %s" % (pa_BVAL_path, paBVAL))
		if pa_BVEC_path is not None:
			paBVEC = pdir_basename + "processed/%s_dwi-PA.nii.gz" % subject
			runCmd_log("cp %s %s" % (pa_BVEC_path, paBVEC))
		paDWI = pdir_basename + "processed/%s_dwi-PA.nii.gz" % subject
		runCmd_log("cp %s %s" % (pa_DWI_path, paDWI))

	# declare names
	DWI_DN = pdir_basename + "processed/%s_dwi-AP_dn.nii.gz" % subject
	DWI_DN_DG = pdir_basename + "processed/%s_dwi-AP_dn_degibbs.nii.gz" % subject
	# denoise. 
	runCmd_log("dwidenoise %s %s -noise processed/%s_noise.nii.gz" % (DWI, DWI_DN, subject))
	# degibbs.
	runCmd_log("mrdegibbs %s %s" % (DWI_DN, DWI_DN_DG))
	# make mask (useful for checking) ... could be used in dwifslpreproc
	runCmd_log("dwi2mask -fslgrad %s %s %s processed/%s_dwi-AP_dn_mask.nii.gz " % (BVEC, BVAL, DWI_DN_DG, subject))

	# round the bval for NODDI/indexing
	DWI_DN_EDDY_BVAL_ROUNDED = pdir_basename + "processed/%s_dwi-AP_dn_degibbs_ecc_rounded.bval" % subject
	bval = np.genfromtxt(BVAL, delimiter=' ', dtype=int)
	rounded_bval = np.around(bval, decimals=-3)
	# output round bval which is later used for amico
	np.savetxt(DWI_DN_EDDY_BVAL_ROUNDED, rounded_bval, delimiter='', newline=' ', fmt='%i')

	if opts.t1path:
		# EDDY
		# declare names
		DWI_DN_EDDY = pdir_basename + "processed/%s_dwi-AP_dn_degibbs_ecc.nii.gz" % subject
		DWI_DN_EDDY_BVEC = pdir_basename + "processed/%s_dwi-AP_dn_degibbs_ecc.bvec" % subject
		DWI_DN_EDDY_BVAL = pdir_basename + "processed/%s_dwi-AP_dn_degibbs_ecc.bval" % subject
	
		# Unwarping using T1w image 
		runCmd_log("dwifslpreproc -fslgrad %s %s -rpe_none -pe_dir ap -readout_time %s -export_grad_fsl %s %s %s %s" % (BVEC, BVAL,
										TotalReadoutTime,
										DWI_DN_EDDY_BVEC, DWI_DN_EDDY_BVAL,
										DWI_DN_DG, DWI_DN_EDDY))

		assert os.path.exists(DWI_DN_EDDY), "DWI preprocessing did not finish. Is GCC loaded?"

		# N4 bias field correction for T1w image
		T1W_N4 = pdir_basename + "processed/%s_T1w_bfc.nii.gz" % subject
		runCmd_log("N4BiasFieldCorrection -d 3 -i %s -o %s" % (T1W, T1W_N4))

		# ANTS brain extraction; antsbet does do a N4bfc, but this way makes sure that the structural template is unbiased for registration. Unlikely to have much of an effect w/ or w/out N4...
		runCmd_log(antsBetCmd(numthreads = numthreads, input_image = T1W_N4, output_image_brain = "processed/%s_T1w_bfc_" % subject))

		# declare names
		T1w_brain = pdir_basename + "processed/%s_T1w_bfc_BrainExtractionBrain.nii.gz" % subject


		# get the mean B0 images
		img = nib.load(DWI_DN_EDDY)
		img_data = img.get_fdata()
		bzero_data = img_data[:,:,:,rounded_bval==0]

		# declare names
		DWI_DN_EDDY_B0_MEAN = pdir_basename + "processed/%s_dwi-AP_dn_degibbs_ecc_b0_mean.nii.gz" % subject
		DWI_DN_EDDY_B0_MEAN_BRAIN = pdir_basename + "processed/%s_dwi-AP_dn_degibbs_ecc_b0_mean_brain.nii.gz" % subject

		nib.save(nib.nifti1.Nifti1Image(bzero_data.mean(3), header=img.header, affine=img.affine), DWI_DN_EDDY_B0_MEAN)
		runCmd_log("bet %s %s -f .2" % (DWI_DN_EDDY_B0_MEAN, DWI_DN_EDDY_B0_MEAN_BRAIN))

		# linear registration of T1w_brain to B0_mean_brain
		ref = DWI_DN_EDDY_B0_MEAN_BRAIN
		mov = T1w_brain
		out = 'processed/lin_T1w_to_b0.nii.gz'
		runCmd_log(antsLinearRegCmd(numthreads = numthreads,
											reference  = ref,
											mov = mov,
											out_basename = out,
											outdir = None,
											use_float=False))

		# non linear registration of B0_mean_brain to lin_T1w_to_b0.nii.gz
		ref = 'processed/lin_T1w_to_b0.nii.gz'
		mov = DWI_DN_EDDY_B0_MEAN_BRAIN
		out = 'processed/b0_to_linT1.nii.gz'
		runCmd_log(antsNonLinearRegCmd(numthreads = numthreads,
												reference = ref,
												mov = mov,
												out_basename = out,
												outdir = None,
												use_float = False))

		# apply transformation to DWI data
		# declare names
		DWI_DN_EDDY_DC = pdir_basename + "processed/%s_dwi-AP_dn_degibbs_ecc_dc.nii.gz" % subject
		warps = ["processed/b0_to_linT1.nii.gz_0Warp.nii.gz"]
		runCmd_log(antsApplyTransformCmd(reference = ref,
													mov = DWI_DN_EDDY,
													warps = warps,
													outname = DWI_DN_EDDY_DC,
													inverse = False, multipleimages = True))

		# subject_dwi-AP_ecc_dc_mask. Note: I'm using the linear transformed T1w mask to avoid fitting unwarped distortions
		# declare names
		DWI_DN_EDDY_DC_MASK = pdir_basename + "processed/%s_dwi-AP_dn_degibbs_ecc_dc_mask.nii.gz" % subject
		DWI_DN_EDDY_DC_ERO1 = pdir_basename + "processed/%s_dwi-AP_dn_degibbs_ecc_dc_mask_ero1.nii.gz" % subject
		runCmd_log("fslmaths processed/lin_T1w_to_b0.nii.gz -bin %s" % DWI_DN_EDDY_DC_MASK)
		runCmd_log("fslmaths processed/lin_T1w_to_b0.nii.gz -bin -ero %s" % DWI_DN_EDDY_DC_ERO1)

		runCmd_log("mkdir QC")
		runCmd_log("fslsplit %s QC/" % DWI_DN_EDDY_DC)
		runCmd_log("slicesdir -p processed/lin_T1w_to_b0.nii.gz QC/*")
		runCmd_log("rm -r QC")
		runCmd_log("mv slicesdir processed/QC_unwarped_dwi")


	if opts.pab0path:
		# unwarping using topup / eddy. I think that dwifslpreproc needs bvec/bval to be imported via rpe_header to work, so I'll use topup/eddy instead. Maybe try adding zero'd bvec?

		AP_B0_bval = np.genfromtxt(BVAL, delimiter=" ")
		AP_B0_bval_round = np.round(AP_B0_bval,-3).astype(int)
		AP_B0_index = AP_B0_bval_round==0
		num_AP_B0 = len(AP_B0_bval_round[AP_B0_index])

		if pa_BVAL_path is None:
			n_vols = nib.load(paDWI).get_fdata().shape[-1]
			PA_B0_index = np.zeros((n_vols), dtype = bool)
			PA_B0_index[:N_PA_B0] = True
			num_PA_B0 = N_PA_B0
		else:
			PA_B0_bval = np.genfromtxt(paBVAL, delimiter=" ")
			PA_B0_bval_round = np.round(PA_B0_bval,-3).astype(int)
			PA_B0_index = PA_B0_bval_round==0
			num_PA_B0 = len(PA_B0_bval_round[PA_B0_index])

		acqparams = []
		for i in range(num_AP_B0):
			acqparams.append([0,-1,0,TotalReadoutTime])
		for j in range(num_PA_B0):
			acqparams.append([0,1,0,TotalReadoutTime])
		acqparams = np.array(acqparams)

		# extract_b0s
		AP_dwi_img = nib.load(DWI)
		AP_dwi_img_data = AP_dwi_img.get_fdata()
		AP_B0_data = AP_dwi_img_data[:,:,:,AP_B0_index]
		AP_B0_out = "processed/%s_dwi-b0-AP.nii.gz" % (subject)
		nib.save(nib.Nifti1Image(AP_B0_data, AP_dwi_img.affine),AP_B0_out)

		PA_dwi_img = nib.load(paDWI)
		PA_dwi_img_data = PA_dwi_img.get_fdata()
		PA_B0_data = PA_dwi_img_data[:,:,:,PA_B0_index]
		PA_B0_out = "processed/%s_dwi-b0-PA.nii.gz" % (subject)
		nib.save(nib.Nifti1Image(PA_B0_data, PA_dwi_img.affine),PA_B0_out)

		AP_PA_B0_out = "processed/%s_dwi-b0-pair.nii.gz" % (subject)
		nib.save(nib.Nifti1Image(np.concatenate((AP_B0_data, PA_B0_data),3), AP_dwi_img.affine), AP_PA_B0_out)
		np.savetxt('processed/acqparams.txt', acqparams, fmt='%s')

		#Run top-up
		runCmd_log("topup --imain=%s --datain=processed/acqparams.txt --config=b02b0.cnf --iout=processed/%s-b0_dc --out=processed/%s-topup-results" % (AP_PA_B0_out, subject, subject))
		ub0_img = nib.load("processed/%s-b0_dc.nii.gz" % (subject))
		
		# create an unwarped average b0 image that may be useful for registration
		ub0_data = ub0_img.get_fdata()
		ub0_data = ub0_data.mean(3)
		nib.save(nib.Nifti1Image(ub0_data,ub0_img.affine), "processed/%s-b0_dc_mean.nii.gz" % (subject))
		runCmd_log("bet processed/%s-b0_dc_mean.nii.gz processed/%s-b0_dc_mean_brain -m -f 0.2" % (subject, subject))


		# create index file for eddy
		np.savetxt("processed/index.txt", np.ones(AP_dwi_img_data.shape[3]), fmt='%d')

		runCmd_log("eddy_openmp --imain=%s --mask=processed/%s-b0_dc_mean_brain_mask --acqp=processed/acqparams.txt --index=processed/index.txt --bvecs=%s --bvals=%s --fwhm=0 --topup=processed/%s-topup-results --flm=quadratic --out=processed/%s_dwi-AP_dn_degibbs_ecc_dc" % (DWI_DN_DG, subject, BVEC, BVAL, subject, subject))

		# declare names
		DWI_DN_EDDY_DC = pdir_basename + "processed/%s_dwi-AP_dn_degibbs_ecc_dc.nii.gz" % subject
		DWI_DN_EDDY_BVEC = pdir_basename + "processed/%s_dwi-AP_dn_degibbs_ecc_dc.bvec" % subject
		DWI_DN_EDDY_BVAL = pdir_basename + "processed/%s_dwi-AP_dn_degibbs_ecc_dc.bval" % subject
		DWI_DN_EDDY_DC_MASK = pdir_basename + "processed/%s-b0_dc_mean_brain_mask.nii.gz" % subject
		runCmd_log("cp processed/%s_dwi-AP_dn_degibbs_ecc_dc.eddy_rotated_bvecs %s" % (subject, DWI_DN_EDDY_BVEC))
		runCmd_log("cp %s %s" % (BVAL, DWI_DN_EDDY_BVAL))

	# Calculate DTI metrics
	# Add option here for optional refitting to eroded mask
	runCmd_log("dtifit -k %s -r %s -b %s -m %s -o processed/%s_dwi-AP_dn_degibbs_ecc_dc_brain" % (DWI_DN_EDDY_DC,
							DWI_DN_EDDY_BVEC,
							DWI_DN_EDDY_BVAL,
							DWI_DN_EDDY_DC_MASK,
							subject))
	runCmd_log("fslmaths processed/%s_dwi-AP_dn_degibbs_ecc_dc_brain_MD.nii.gz -thr 0.0001 -recip processed/%s_dwi-AP_dn_degibbs_ecc_dc_brain_invMD.nii.gz" % (subject, subject))
	runCmd_log("fslmaths processed/%s_dwi-AP_dn_degibbs_ecc_dc_brain_L2.nii.gz -add processed/%s_dwi-AP_dn_degibbs_ecc_dc_brain_L3.nii.gz -div 2 processed/%s_dwi-AP_dn_degibbs_ecc_dc_brain_RD.nii.gz" % (subject, subject, subject))

	if opts.runrestore:
		# adapted from https://github.com/imagen2/imagen_processing/blob/master/fsl_dti/restore.py
		# dipy page: http://nipy.org/dipy/examples_built/restore_dti.html
		# load dti data
		img = nib.load(DWI_DN_EDDY_DC)
		# is this really necessary? why not just used the masked data?
		dataraw = img.get_fdata()
		maskdata = nib.load(DWI_DN_EDDY_DC_MASK).get_fdata()
		data = img.get_fdata()
		data[maskdata!=1] = 0
		bvals, bvecs = io.read_bvals_bvecs(DWI_DN_EDDY_BVAL, DWI_DN_EDDY_BVEC)
		# load bvec and bvals
		gtab = cg.gradient_table(bvals, bvecs)
		# noise estimation from the b=0
		sigma = ne.estimate_sigma(dataraw[:,:,:,rounded_bval==0])
		sigmamean = np.mean(sigma)
		# tensor computation using restore
		tenmodel = dti.TensorModel(gtab,fit_method='RESTORE', sigma=sigmamean)
		tenfit = tenmodel.fit(data)

		FA = fractional_anisotropy(tenfit.evals)
		MD = mean_diffusivity(tenfit.evals)
		AD = axial_diffusivity(tenfit.evals)
		RD = radial_diffusivity(tenfit.evals)
		MO = mode(tenfit.evecs)

		# change output names to use '-' instead of '_' so there isn't an issues with the QC
		tenfit.evals[np.isnan(tenfit.evals)] = 0
		evals1_img = nib.Nifti1Image(tenfit.evals[:,:,:,0].astype(np.float32), img.get_affine())
		nib.save(evals1_img, "processed/%s_dwi-AP_dn_degibbs_ecc_dc_brain_restore-L1.nii.gz" % subject)
		evals2_img = nib.Nifti1Image(tenfit.evals[:,:,:,1].astype(np.float32), img.get_affine())
		nib.save(evals2_img, "processed/%s_dwi-AP_dn_degibbs_ecc_dc_brain_restore-L2.nii.gz" % subject)
		evals3_img = nib.Nifti1Image(tenfit.evals[:,:,:,2].astype(np.float32), img.get_affine())
		nib.save(evals3_img, "processed/%s_dwi-AP_dn_degibbs_ecc_dc_brain_restore-L3.nii.gz" % subject)

		tenfit.evecs[np.isnan(tenfit.evecs)] = 0
		evecs_img1 = nib.Nifti1Image(tenfit.evecs[:,:,:,:,0].astype(np.float32), img.get_affine())
		nib.save(evecs_img1, "processed/%s_dwi-AP_dn_degibbs_ecc_dc_brain_restore-V1.nii.gz" % subject)
		evecs_img2 = nib.Nifti1Image(tenfit.evecs[:,:,:,:,1].astype(np.float32), img.get_affine())
		nib.save(evecs_img2, "processed/%s_dwi-AP_dn_degibbs_ecc_dc_brain_restore-V2.nii.gz" % subject)
		evecs_img3 = nib.Nifti1Image(tenfit.evecs[:,:,:,:,2].astype(np.float32), img.get_affine())
		nib.save(evecs_img3, "processed/%s_dwi-AP_dn_degibbs_ecc_dc_brain_restore-V3.nii.gz" % subject)

		FA[np.isnan(FA)] = 0
		FA[maskdata!=1] = 0
		fa_img = nib.Nifti1Image(FA.astype(np.float32), img.get_affine())
		nib.save(fa_img, "processed/%s_dwi-AP_dn_degibbs_ecc_dc_brain_restore-FA.nii.gz" % subject)

		MD[np.isnan(MD)] = 0
		MD[maskdata!=1] = 0
		md_img = nib.Nifti1Image(MD.astype(np.float32), img.get_affine())
		nib.save(md_img, "processed/%s_dwi-AP_dn_degibbs_ecc_dc_brain_restore-MD.nii.gz" % subject)

		RD[np.isnan(RD)] = 0
		RD[maskdata!=1] = 0
		rd_img = nib.Nifti1Image(RD.astype(np.float32), img.get_affine())
		nib.save(rd_img, "processed/%s_dwi-AP_dn_degibbs_ecc_dc_brain_restore-RD.nii.gz" % subject)

		MO[np.isnan(MO)] = 0
		MO[maskdata!=1] = 0
		mo_img = nib.Nifti1Image(MO.astype(np.float32), img.get_affine())
		nib.save(mo_img, "processed/%s_dwi-AP_dn_degibbs_ecc_dc_brain_restore-MO.nii.gz" % subject)

	# NODDI
	noddi_dir = "processed/noddi"
	runCmd_log("mkdir -p " + noddi_dir)
	os.chdir(noddi_dir)

	runCmd_log("zcat %s > subject4d.nii" % (DWI_DN_EDDY_DC))
	runCmd_log("zcat %s > mask.nii" % (DWI_DN_EDDY_DC_MASK))

	amico.core.setup()
	scheme_name = ("amico.scheme")
	amico.util.fsl2scheme(DWI_DN_EDDY_BVAL_ROUNDED,
								DWI_DN_EDDY_BVEC,
								schemeFilename=scheme_name)
	ae = amico.Evaluation("","")
	ae.load_data(dwi_filename = "subject4d.nii",
					scheme_filename = "amico.scheme",
					mask_filename = "mask.nii",
					b0_thr = 0)
	ae.set_model("NODDI")
	ae.set_config('doDebiasSignal', True)
	ae.set_config('DWI-SNR', 30.0)
	ae.generate_kernels(regenerate = True)
	ae.load_kernels()
	ae.fit()
	ae.save_results()
	for metric in ['ICVF','OD', 'ISOVF']:
		runCmd_log("cp AMICO/NODDI/FIT_%s.nii.gz ../%s_dwi-AP_dn_degibbs_ecc_dc_brain_%s.nii.gz" % (metric, subject, metric))
	runCmd_log("rm -rf mask.nii subject4d.nii kernels")
	
	# There are spikes in the OD/ICVF histogram images, but that seems to be okay? -> https://github.com/daducci/AMICO/issues/8
	
	# output QC logs and histograms
	DWI_METRICS = np.sort(glob.glob("processed/%s_dwi-AP_dn_degibbs_ecc_dc_brain_*.nii.gz" % (subject)))
	generate_qc_tsv(images = DWI_METRICS,
						outname = 'processed/%s_dwi-AP_dn_degibbs_ecc_dc_brain_tf.log' % subject,
						sep = "\t",
						generate_histogram = True)

if __name__ == "__main__":
	parser = getArgumentParser()
	opts = parser.parse_args()
	run(opts)

